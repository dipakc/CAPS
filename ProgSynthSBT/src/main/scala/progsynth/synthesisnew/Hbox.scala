package progsynth.synthesisnew

import progsynth.ProgSynth.Counter
import progsynth.types._
import progsynth.types.Types._
import scala.xml.Elem
import progsynth.utils._
import scalaz._
import scalaz.Scalaz._
import org.kiama.rewriting.Rewriter.{Term=> KTerm, _}
import progsynth.proofobligations.POGenerator
import progsynth.debug.PSDbg
import progsynth.ProgSynth.toRichFormula
import progsynth.printers.XHTMLPrinters2
import SynthUtils._
import progsynth.synthesisold.ProgContext
import progsynth.synthesisold.EmptyProgContext

//-----------------------------------------
/** Data structures required for hierarchical frame display
 */
abstract class HNode() {
	/** Generates hierarchical display of hnode object. */
	def hnodeToXHtml(isEntryNode: Boolean): Elem = this match {
		case hsingle: HSingle => hsingle.hSingleToXHtml(isEntryNode)
		case hbox: HBox => hbox.hBoxToXHtml()
	}

}

case class HSingle(synthNode: SynthNode) extends HNode() {

	def hSingleToXHtml(isEntryNode: Boolean): Elem = {
		val retVal = this.synthNode.nodeObj match {
			case asgnDeriv: AsgnDerivation =>
				XHTMLPrinters2.asgnDerivation2ToHtml(asgnDeriv)(None)
			case ifDeriv: IfDerivation =>
				XHTMLPrinters2.ifDerivation2ToHtml(ifDeriv)
			case step: CalcProofStep =>
				<div class='CalcProofStep'>
					{ if(!isEntryNode) {
						val tacticRel = this.synthNode.tactic.getRelation
						var relationDiv = tacticRel.map(XHTMLPrinters2.fnToHtml(_)).getOrElse(<div>Q:&nbsp;</div>)
						<div class="hint">
							<div class='tacticRelation'>{relationDiv}</div>
							<div class='HintContent'>
								{this.synthNode.tactic.getHint()}
							</div>
						</div>
						}
					}
					<div class="AsgnDerivStep">
						<div class="tacticRelationSpace"></div>
						<div class ="StepTerm">
							{XHTMLPrinters2.termToHtml(step.coreObj)}
						</div>
					</div>
				</div>
		}
		retVal
	}

}

/**First first node in path is the same as the entryNode
 * TODO: Since it has mutable data, make it a non case class
 * TODO: make path private member. Allow to append member but removing element from path should not be allowed
 * TODO: Instead of making path as var, use ListBuffer
 * TODO: entryNode is redundant*/
case class HBox(val entryNode: HSingle, var path: List[HNode], pBox: Option[HBox]) extends HNode() {
	assert(!path.isEmpty) ///**First first node in path is the same as the entryNode */
	def append(hnode: HNode) = { path = path ::: List(hnode)}

	/**Returns the frame associated with the entryNode*/
	def getFrame(): Frame = entryNode.synthNode.frame

	/** Ruturns the frames associated with the step-in tactic that generated the frame.
	 *  (There may be multiple frames generated by the a step-in tactic )
	 *  The head of the returned list is the top frame.
	 *  HBox: (parentFrame (this))      Frames: pFrame --> iFrame --> cFrame */
	def getFrames(): List[Frame] = {
		var retVal: List[Frame] = Nil
		this.pBox match {
			case None =>
				retVal =  this.getFrame() :: Nil
			case Some(parentBox) =>
				val pFrame = parentBox.getFrame()
				var cFrame = this.getFrame()
				while(cFrame != pFrame) {
					retVal ::= cFrame
					cFrame.parent match {
						case Some(parFrame) => parFrame
						case None => throw new RuntimeException("Reached top without encountering frame of parent box")
					}
				}
		}
		retVal
	}

	def getTactic() = entryNode.synthNode.tactic

	def hBoxToXHtml(): Elem = {
		val retVal =
			<div class="HintAndHBox">
			<div class="hint"> {this.getTactic.getHint} </div>
			<div class="HBox">{
				<div class="Frame"> {
					//Get frame corresponding to this hbox
					val frame = this.getFrame
					//generate context summary.
					frame.getSummary().toXHtml
				} </div> ++
				{
					this.path.head.hnodeToXHtml(isEntryNode= true) ++
					this.path.tail.map{_.hnodeToXHtml(isEntryNode = false)}
				}
			}</div>
			</div>
		retVal
	}

}

object HBoxUtils {
	/** creates hbox from a non empty SynthNode list*/
	def getHBox(nodeList: List[SynthNode]): HBox = {
		assert(nodeList.length > 0)
		//always create outer hbox even if the first node is not a stepin node
		val hnode = HSingle(nodeList.head)
		var retVal = HBox(entryNode = hnode, path = hnode::Nil, pBox = None)

		var cBox: HBox = retVal //current box

		for (node <- nodeList.tail) {
			val hnode = HSingle(node)
			node.tactic match {
				case _: StepInTactic =>
					val newBox = HBox(hnode, hnode::Nil, Some(cBox)) //create box
					cBox.append(newBox) //add empty box to current box
					cBox = newBox //update current box
				case _: StepOutTactic =>
					cBox = cBox.pBox.get
					cBox.append(hnode)
				case _ =>
					cBox.append(hnode)
			}
		}
		retVal
	}
}
//-----------------------------------------
